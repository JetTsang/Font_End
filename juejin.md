---
theme: geek-black
---
## 自我介绍
大家好，我叫[JetTsang](https://juejin.cn/user/1082334121297213)，之前都是在掘金潜水来着，现在偶尔做一些内容输出吧。

## 问题引出 

有一天产品小姐姐跑过来说，这个上传附件📎的功能不好用

什么？在实现了`断点续传`和`秒传`两大杀手锏之后，还有哪个用户（刁民）敢不满意？

一番拉扯之后，发现是反馈扫描文件的速度太慢了。

奇怪了，扫描是计算md5呢，应该不会很慢啊。（md5是一种哈希算法，可以得到文件的标识，文件的标识简单理解为文件的`身份证号码`即可）

看了一下生产上的数据，发现这个用户居然上传了1G多的文件？？？

1G多的文件计算md5肯定慢啰

之前测试的时候用的最大都只是几十m，所以就没发现有这个问题（别问这么明显为啥没考虑到，问就是时间紧任务急，先上线再优化）

## 思考
既然计算md5慢，那不计算md5行不行呢？

首先回顾一下文件上传的步骤
1. 通过用户的选择，拿到文件的file对象
2. 转成ArrayBuffer,并进行分片，并且计算MD5
3. 将md5请求后端是否需要上传？或者已经传了多少了，只传剩下的，或者能不能传
4. 并发开启上传请求
5. 告诉后端传完了，可以合并了，后端合并之后返回个结果

计算md5是实现秒传必须要的，不计算的同时也会带来其他的问题：比如服务端接收到的文件损坏等等



那就只能从计算md5这方面去入手了，这就不得不请出今天的主角儿:`WebAssembly`

### WebAssembly
我们的浏览器现在只能运行JavaScript，但JavaScript的效率其实并不高，可以设计一个虚拟微处理器，它可以将任何高级语言转换成可以在所有主流浏览器上运行的机器码，那浏览器环境下不就以跑它了吗？

其实说白了，WASM不是一种编程语言，它是一种将其他编程语言编写的代码转换为浏览器可理解的机器代码的技术。或者说它是一种被设计为其他语言的**编译目标**，允许服务器端代码(如C或C++代码)被编译成WASM并在浏览器中执行。

它的优点有：


缺点：

多线程还不是很友好 ？

内存有限？

不能直接操作dom（这也是为了安全吧）

说了这么多，让我们看看大厂的应用场景：视频处理、3D渲染、多媒体游戏、加密计算和AR/VR实时应用程序等

这里头的加密计算不就是啰。


其实还有个原因，是因为计算md5的时候直接是同步拿到文件就直接计算的，这样会导致计算的时间内浏览器无法处理用户的交互，所以会导致用户更加烦躁。这样又让我想到了多线程，这不就可以用Worker来解决了吗？ 


## 解决方案
于是乎，解决方案初步成型：`WebAssembly` `+` `Web Worker`

可以利用Worker来开启一个或多个`辅助线程`去做计算，来解决计算期间用户无响应以及优化md5的问题。

### 调研
既然用wasm ,那么先去其他大厂踩踩点，经过仔细搜寻🔍

比如qq邮箱的这里也是有包含md5计算的
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73e9c402ac5347e4850b35e2522295b0~tplv-k3u1fbpfcp-watermark.image?)
也用到了wasm
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55dfd94363104fb9b0fc5e75dadcd555~tplv-k3u1fbpfcp-watermark.image?)



PS:我可没看盗版阿凡达啊，只是下载来测试的（认真脸）



再比如 
'一家把我们用户体验放在第一位的公司”啊逼，就用上了，[WebAssembly 软解 HEVC 在 B 站的实践](https://www.bilibili.com/read/cv16257864/)







## 测试

## 准备
当然生产上用go做的wasm还是有体积点大的，因为go的设计是多端能力导致GC依赖甩不掉，难以做到轻量

## 结果
测试机器：MacBookPro 14 Apple M1 Pro

测试文件：阿凡达水之道

测试我们分种情况阶段：
1. js主线程计算（不分片）
2. 主线程分片计算
3. 辅助线程计算
4. 辅助线程分片计算


### 测试代码


### 结果
首先是主线程整个计算

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/154ba43199124204b7471f8740589e49~tplv-k3u1fbpfcp-watermark.image?)
有点夸张啊，效率高4倍，有点东西看来

加入分片计算之后呢？

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8f8a801b0bd4ab8bf839312e8f2f5b2~tplv-k3u1fbpfcp-watermark.image?)
嗯。。。分片之后更慢也是理所当然，因为分片也要时间呢。

那么在辅助进程当中呢？



## 另外

如果要在生产上，也可以使用这
[hash-wasm](https://github.com/Daninet/hash-wasm)

它的使用方法：

贴一张，使用它来计算的图


## 更多优化点
1. 是不是可以增加文件切片的md5校验呢？假如文件传输途中损坏也可以只重传那个片段
2. worker/以及js和wasm之间的数据传递，损耗怎样能减少呢？


## 参考资料

[WebAssembly在QQ邮箱中的一次实践](https://cloud.tencent.com/developer/article/2034402)

[wasm+js实现文件获取md5示例详解](https://www.jb51.net/article/258610.htm)