<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        // https://juejin.cn/post/6946022649768181774#heading-14

        // 1.类型判断
        function getType (data){
            return Object.prototype.toString.call(data).slice(8,-1)
        }

        // 2.数组去重
        // 核心思路：找到第一次出现的item
        // 这里当然只针对基础类型
        function unique(arr){
            return arr.filter((value,index,arr)=>{
                return arr.indexOf(value) === index
            })
            // 或者用es6的set数据结构
            return Array.from(new Set(arr))
        }

        // 3. 数组扁平化
        // [1,2,[3,4,[5]]] --> [1,2,3,4,5]
        function flatArray(arr){
            // 1. Array.prototype.flat 
            return arr.flat(Infinity)
            // 2. 递归 
            // 这里的解除构，可以解除
            while(arr.some(i=>Array.isArray(i))){
                arr = [].concat(...arr)
            }
            return arr

        }

        // 4. 函数防抖
        // 指定时间内多次触发，只会触发一次
        function debounce(func,wait){
            let timer = null
            return function(...args){
                // 注意这里的上下文
                clearTimeout(timer)
                timer = setTimeout(function(){
                    console.log(this);
                    func.apply(this,args)
                    clearTimeout(timer)
                    timer = null
                },wait)
            }
        }

        // 5. 函数节流
        // 高频触发的时候，指定时间内只触发1次
        function throttle(func,wait){
            let timer = null
            return function (...args){
                if(timer) return 
                timer = setTimeout(()=>{
                    func.apply(this,args)
                    clearTimeout(timer)
                    timer = null
                },wait)
            }
        }
        // 或者用时间搓，同步方法
        function throttleWithTimestamp(func,wait){
            let previousTimestamp = new Date().getTime()
            return function(...args){
                const now = new Date().getTime()
                // 如果现在距离上一次时间超过等待时间，则执行
                if(now - previousTimestamp >wait){
                    func.apply(this,args)
                    // 重置时间
                    previousTimestamp = now
                }
            }
        }

        // 6. 实现 new 关键字 
        // new 关键字 主要做了3 件事
        // 1. 构造函数的this指向对象
        // 2. 设置对象示例的prototype为 Constructor.prototype -->  Constructor 和obj是构造关系
        // 3. 如果构造函数有返回的对象，直接返回
        function objectFactory(){
            console.log(arguments);
            const constructor = Array.prototype.shift.call(arguments) // 从参数里取出第一个入参（构造函数）
            console.log(constructor);
            console.dir(constructor);
            console.log(arguments);
            const obj = Object.create(constructor.prototype) // 建立原型上的联系
            const ret = constructor.apply(obj,arguments) // 执行构造函数，并且接住构造函数返回的对象（若有的话）
            return typeof  ret === 'object' ? (ret || obj) : obj
        }
        function Person(name,age){
            this.name =name
            this.age = age
        }
        console.log(objectFactory(Person,'Jettsang',25));

        // 7. 实现 [] instanceOf Array 
        // 函数 instanceOf(left,right)  
        // 判断 left instanceof right
        function instanceOf(left,right){
            // 拿到左边的原型
            let proto = left.__proto__
            while (true) {
                // 到达原型链的终点,则为null（这里要注意用===来区分undefined和null）
                if(proto === null) return false
                if(proto === right.prototype) return true
                // 继续更新原型
                proto  = proto.__proto__
            }
        }


    </script>
</body>
</html>